#!/usr/bin/env python3.10
# -*- coding: utf-8 -*-

"""
... TBD ...

Exit Codes:
-----------
    0   Everything went fine.
    1   Exception occurred accessing or parsing the configuration file.
    2   Exception occurred in communicating with Docker.
    3   Exception occurred in communicating with Wanda.
    4   A problem with Wanda ocurred.


ToDo:
-----
    - wanda_status() needs Wanda health check.
    - Rework help output.
    - Implement JSON output
    
    
Future:
-------
    - Implement container creation, update and destruction as well.

    
Changelog:
----------
01.03.2024      v0.0        - and so it begins...
"""

import argparse
import os
import docker
import re
import subprocess
import sys
import termcolor
import textwrap
import time
import json
import uuid
from collections import Counter
from typing import List, Dict, Tuple


__version__ = '0.0'
__author__ = 'SÃ¶ren Schmidt'
__email__ = 'soren.schmidt@suse.com'
__maintainer__ = __author__
__license__ = "GPLv3"
__status__ = 'Prototype'


# -----------------
# CLASS DEFINITIONS
# -----------------

class CLI():
    """Provides methods to print colored messages on the terminal."""
    
    @classmethod
    def print_info(cls, text: str) -> None:
        print(termcolor.colored(text, 'blue'))
        
    @classmethod
    def print_fail(cls, text: str) -> None:
        print(termcolor.colored(text, 'red'))

    @classmethod
    def print_warn(cls, text: str) -> None:
        print(termcolor.colored(text, 'yellow'))

    @classmethod
    def print_ok(cls, text: str) -> None:
        print(termcolor.colored(text, 'green'))

    @classmethod
    def print_okfail(cls, text: str, fail: bool = True) -> None:
        cls.print_fail(text) if fail else cls.print_ok(text)


class Config():
    """Represents tcsc configuration.
    
        - self.id (str): UUID used to mark the created containers. 
        - self.wanda_containers (List[str]): List of all Wanda container names.  
        - self.wanda_tag (str): Tag used to identify Wnada containers for tcsc.
    """

    def __init__(self, configfile: str, create: bool = True) -> None:
        """Loads the configuration from `configfile`. If `create` is
        true and `configfile` does not exists, a default configuration
        will be created.

        Args:
            configfile (str):           Filename of JSON configuration.
            create (bool, optional):    Flag if a default configuration shall be created,
                                        if the config file is missing. Defaults to True.
        """

        configfile = os.path.realpath(os.path.expandvars(os.path.expanduser(configfile)))
        try:
            if not os.path.exists(configfile) and create:
                dir, _ = os.path.split(configfile)
                if dir:
                    os.makedirs(dir, mode=0o700, exist_ok=True)
                with open(configfile, 'w') as f:
                    f.write(json.dumps({
                                       'id': str(uuid.uuid1()),
                                       'wanda_containers': ['tcsc-rabbitmq', 'tcsc-postgres', 'tcsc-wanda'],
                                       'wanda_tag': 'com.suse.tcsc.stack'
                                       }, indent=4
                                       )
                            )
            with open(configfile) as f:
                config = json.load(f)
                self.id = config['id']
                self.wanda_containers = config['wanda_containers']
                self.wanda_tag = config['wanda_tag']
        except Exception as err:
            raise ConfigException(f'Error accessing configuration: {err}')


class ConfigException(Exception):
    pass


class Wanda():
    """Represents a Wanda container stack.
    
        - self._containers (Dict[str, Container]):  Dict with the Wand container instances referenced by name.
        - self._docker (docker.DockerClient):  Instance of DockerClient.
    """

    def __init__(self, config: Config) -> None:
        self._docker: docker.DockerClient = docker.from_env()
        self._containers = {container.name: container for container in 
                            self._docker.containers.list(all=True, filters={'label': config.wanda_tag})}
        if set(self._containers.keys()) != set(config.wanda_containers):
            raise WandaException('Not all required Wanda containers are present.')

    @property
    def status(self) -> Dict[str, str]:
        """Returns a dictionary with all Wanda containers and there current status."""
        
        self._update()
        return {container.name: container.status for container in self._containers.values()}
        
    def start(self) -> List[str]:
        """Initiate start of Wanda containers. Only containers, which are in the states
        'exited' or 'created' are going to be started. The method will *not* wait for 
        the containers to be up.
        Returns the names of the started containers."""
        
        started = []
        for container in [c for c in self._containers.values() if c.status in ['exited', 'created']]:
            started.append(container.name)
            container.start()
            
        #TODO: ADD WAITING LOOP WITH TIMEOUT.    
            
            
        return started

    def stop(self) -> List[str]:
        """Stops all Wanda containers. Only containers, which are in the state 'running'
        are going to be stopped.
        Returns the names of the stopped containers."""
        
        stopped = []
        for container in [c for c in self._containers.values() if c.status in ['running']]:
            stopped.append(container.name)
            container.stop()
            
        #TODO: ADD WAITING LOOP WITH TIMEOUT.
            
        return stopped

    def _update(self) -> None:  #TODO: CAN IT BECOME A DECORATOR?
        """Updates the container objects."""
        for container in self._containers.values():
            container.reload()

class WandaException(Exception):
    pass


# ----------------
# HELPER FUNCTIONS
# ----------------

def argument_parse() -> dict:
    """Evaluates the command line arguments."""

    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]),
                                     #usage='\n'.join(usage),
                                     description='Manages containers to use Wanda checks on support files.',
                                     epilog='')

    parser.add_argument('-j', '--json',
                        dest='json_output',
                        action='store_true',
                        required=False,
                        help='output is done in JSON')  
     
    subparsers = parser.add_subparsers(dest='selectors')
    subparsers.required = True
    
    # Selector: wanda
    parser_wanda = subparsers.add_parser('wanda', help='Manages Wanda container stack')
    
    parser_wanda.add_argument(dest='command',
                              action='store',
                              type=str,
                              choices=['start', 'status', 'stop', 'checks'],
                              help='starts, stops, prints the status of the Wanda stack or lists all available checks')
    
    # Selector: hosts
    parser_hosts = subparsers.add_parser('hosts', help='Manages host containers')
    
    # Selector: checks
    parser_checks = subparsers.add_parser('checks',  help='Executes checks')
     
    args_parsed = parser.parse_args()
    
    return args_parsed


# --------------
# TCSC FUNCTIONS
# --------------

def wanda_start(wanda: Wanda) -> bool:
    """Starts the Wanda stack and returns the success."""

    status = True

    started = wanda.start()   
    print(f'Started: {started}')
    
    while True:
        print(wanda.status)
        time.sleep(.5)
     
    
    # present = {c.name: c for c in docker_client.containers.list(all=True, filters={'label': 'com.suse.tcsc.stack'})}
    # for name in 'tcsc-rabbitmq', 'tcsc-postgres', 'tcsc-wanda':
    #     if name not in present:
    #         CLI.print_fail(f'{name:<20} [not found]')
    #     else:
    #         if present[name].status == 'running':
    #             CLI.print_warn(f'{name:<20} [already running]')
    #         else:
    #             present[name].start()  # Add catching docker.errors.APIError
    #             while present[name].status != 'running':
    #                 CLI.print_warn(f'{name:<20} {[present[name].status]}\r')  
    #                 time.sleep(1)
                
                
                
                
    #             print('START', name, present[name].status)
        
    # return status


def wanda_stop(wanda: Wanda) -> bool:
    """Stops the Wanda stack and returns the success."""

    status = True

    wanda.stop()
    return status




def wanda_status(wanda: Wanda) -> bool:
    """Prints the status of Wanda stack on screen
    and returns operational state."""

    operational = True

    for name, status in wanda.status.items():
        text = f'{name:<20} [{status}]'
        if status != 'running':
            operational = False
        CLI.print_okfail(text, fail=status != 'running')

    if operational: #TODO: ADD HEALTH CHECK!        
        pass     
              
    CLI.print_ok('\nWanda is operational.') if operational else CLI.print_fail('\nWanda is not operational!')
    return operational


def main() -> None:
    
    arguments = argument_parse()  
    
    try:
        config = Config('~/.config/tcsc/config')
        wanda = Wanda(config)

        # print(arguments)
        if arguments.selectors == 'wanda':
            
            if arguments.command == 'start':
                sys.exit(0) if wanda_start(wanda) else sys.exit(4)
                
            elif arguments.command == 'stop':
                sys.exit(0) if wanda_stop(wanda) else sys.exit(4)
            
            elif arguments.command == 'status':
                sys.exit(0) if wanda_status(wanda) else sys.exit(4)
                
            elif arguments.command == 'checks':
                pass            
        
        elif arguments.selectors == 'hosts': 
            pass 
        
        elif arguments.selectors == 'checks': 
            pass 
    
    except ConfigException as err:
        print(err, file=sys.stderr)
        sys.exit(1)
    except docker.errors.DockerException as err:
        print(f'Docker error: {err}', file=sys.stderr)
        sys.exit(2)
    except WandaException as err:
        print(f'Wanda error: {err}', file=sys.stderr)
        sys.exit(3)
    
    # Bye.
    sys.exit(0)


    
if __name__ == '__main__':
    main()