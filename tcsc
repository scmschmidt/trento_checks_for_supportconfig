#!/usr/bin/env python3.10
# -*- coding: utf-8 -*-

"""
... TBD ...

Exit Codes:
-----------
    0   Everything went fine.
    1   Exception occurred accessing or parsing the configuration file.
    2   Exception occurred in communicating with Docker.
    3   Exception occurred in communicating with Wanda.
    4   A problem with Wanda ocurred.
    5   A problem with a host container ocurred.
    6   Something is wrong with the check.
    9   An unknown error ocurred.
   10   Feature not yet implemented.


ToDo:
-----
    - Extracting hostnames from supportconfig makes check results more readable.
    - Implement restart of exited host containers.
    - Think about labels and stuff and what really needs to be in the config file.
    - Talk to Jochen how to integrate `tcsc` into his web project. Importing `tcsc` might be an easy way. 
    - THink about filter for listing checks to get a better overview. 
    - Think about start protection for same support files for the same group.
    - Check if all created docker resources really get removed.
    - Checks should be show, which host groups can use them (provided supportfiles)
    - Autodetection of provider should be implemented.
    - Parallelize check executions to be faster.
    - Rework help output.
    - Implement JSON output
    - Implement signal handling (catching interrupts)
    - Check if we can have non-colored output best.
    - Better table output with flexible column width.
    
    
Future:
-------
    - Implement container creation, update and destruction as well.

    
Changelog:
----------
01.03.2024      v0.0        - and so it begins...
"""

import argparse
import collections
import os
import docker
#import random
#import string
import sys
from collections import Counter
from rabbiteer import Rabbiteer
from typing import List, Dict, Tuple
from tcsc_config import *
from tcsc_cli import *
from tcsc_wanda import *
from tcsc_hosts import *
from tcsc_supportfiles import *


__version__ = '0.0'
__author__ = 'SÃ¶ren Schmidt'
__email__ = 'soren.schmidt@suse.com'
__maintainer__ = __author__
__license__ = "GPLv3"
__status__ = 'Prototype'


def argument_parse() -> dict:
    """Evaluates the command line arguments."""

    #TODO: REFORMAT PARSER BLOCK AND ADD NECESSARY ATTRIBUTES, LIKE TYPE ETC: 

    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]),
                                     #usage='\n'.join(usage),
                                     description='Manages containers to use Wanda checks on support files.',
                                     epilog='')

    parser.add_argument('-j', '--json',
                        dest='json_output',
                        action='store_true',
                        required=False,
                        help='output is done in JSON')  
     
    selectors = parser.add_subparsers(dest='selectors')
    selectors.required = True
    
    # Selector: wanda
    wanda = selectors.add_parser('wanda', help='Manages Wanda container stack.')
    wanda_commands = wanda.add_subparsers(dest='wanda_commands')
    wanda_commands.required = True
    
    wanda_start = wanda_commands.add_parser('start', help='Starts Wanda containers.')
    wanda_status = wanda_commands.add_parser('status', help='Prints status of Wanda.')
    wanda_stop = wanda_commands.add_parser('stop', help='Stops Wanda containers.') 

    # Selector: hosts
    hosts = selectors.add_parser('hosts', help='Manages host containers.')
    hosts_commands = hosts.add_subparsers(dest='host_commands')
    hosts_commands.required = True
 
    hosts_start = hosts_commands.add_parser('start', help='Starts host group.')
    hosts_stop = hosts_commands.add_parser('stop', help='Stops host group.')
    hosts_remove = hosts_commands.add_parser('remove', help='Removes host group.')
    hosts_status = hosts_commands.add_parser('status', help='Prints status of hosts.')
    hosts_logs = hosts_commands.add_parser('logs', help='Lists logs of a host container.')
    
    for p in  hosts_start, hosts_status, hosts_stop, hosts_remove:
        p.add_argument(metavar='GROUPNAME',
                              nargs='?',
                              dest='hostgroup',
                              help='name of the host group')
    
    hosts_start.add_argument(metavar='SUPPORTFILE',
                             dest='supportfiles',
                             nargs='*',
                             help='supportfiles (like supportconfig)')
 
    hosts_status.add_argument('-d', '--details',
                              dest='host_details',
                              action='store_true',
                              required=False,
                              help='shows more details.')  
        
    hosts_logs.add_argument(metavar='CONTAINERNAME',
                             dest='containername',
                             help='name of the host container')    
    hosts_logs.add_argument('-l', '--lines',
                              metavar='N',
                              dest='last_lines',
                              type=int,
                              required=False,
                              help='show only the last N lines')  
        
    # Selector: checks
    checks = selectors.add_parser('checks',  help='Manages checks.')
    checks_commands = checks.add_subparsers(dest='checks_commands')
    
    checks_list = checks_commands.add_parser('list', help='Lists available checks.')
    
    checks_list.add_argument('-d', '--details',
                             dest='check_details',
                             action='store_true',
                             required=False,
                             help='shows more details.') 
    
    checks_run = checks_commands.add_parser('run', help='Runs Trento checks.')
    
    checks_run.add_argument(metavar='GROUPNAME',
                            dest='hostgroup',
                            help='name of the host group')
    checks_run.add_argument('-p', '--provider',
                            metavar='PROVIDER',
                            dest='provider',
                            choices=['default','kvm','vmware','azure','aws', 'gcp'],
                            default='default',
                            type=str,
                            required=False,
                            help='provider to use for the check')
    run_exclusive = checks_run.add_mutually_exclusive_group()
    run_exclusive.add_argument('-g', '--group',
                               metavar='GROUP',
                               dest='check_groups',
                               action='append',
                               type=str,
                               required=False,
                               help='use only checks of that group')
    run_exclusive.add_argument('-c', '--check',
                               metavar='CHECK',
                               action='append',
                               type=str,
                               required=False,
                               dest='requested_checks',
                               help='use only the check with this ID')
      
    args_parsed = parser.parse_args()
    
    #TODO: Checking lines (hosts logs) should be a positive integer.
    
    return args_parsed


def wanda_start(wanda: WandaStack) -> bool:
    """Starts the Wanda stack and returns the success."""

    try:
        started = wanda.start()   
    except WandaException as err:
        CLI.print_json(json.dumps({'success': False, 'error': err }))
        CLI.print_fail(err)
        return False
    else:
        if started:
            CLI.print_info(f'''Started containers: {', '.join(started)}''')
        CLI.print_json({'success': True, 'started_containers': started})
        CLI.print_ok('Wanda completely started.')
    return True
 
        
def wanda_stop(wanda: WandaStack) -> bool:
    """Stops the Wanda stack and returns the success."""

    try:
        stopped = wanda.stop()
    except WandaException as err:
        CLI.print_json(json.dumps({'success': False, 'error': err }))
        CLI.print_fail(err)
        return False
    else:
        if stopped:
            CLI.print_info(f'''Stopped containers: {', '.join(stopped)}''')
        CLI.print_json({'success': True, 'stopped_containers': stopped})                        
        CLI.print_ok('Wanda completely stopped.')
    return True


def wanda_status(wanda: WandaStack) -> bool:
    """Prints the status of Wanda stack on screen
    and returns operational state."""

    CLI.print_header('Wanda', margin_bottom=1)
    output = []
    json_obj = {'containers': []}
    for name, status in wanda.container_status.items():
        output.append({'name': name, 
                       'status': CLI.ok if status == 'running' else CLI.error,
                       'status_text': status})
        json_obj['containers'].append({'name': name, 'status': status})
    CLI.print_status(output)    

    if wanda.status:
        CLI.print_ok('\nWanda is operational.')
        json_obj['operational'] = True
    else:
        CLI.print_fail('\nWanda is not operational!')
        json_obj['operational'] = False
    CLI.print_json(json_obj)
    
    return True if wanda.status else False
    

def hosts_start(hosts: HostsStack, hostgroup: str, supportfiles: List[str]) -> bool:
    """Starts a host container with the given supportfiles as member of the given host group."""

    #TODO: JSON OUTPUT

    if hostgroup in hosts.hostgroups:
        if supportfiles:
            CLI.print_warn(f'Starting existing host group "{hostgroup}". Supportfiles are ignored!')
        if hosts.start_hostgroup(hostgroup):
            CLI.print_ok(f'Host group "{hostgroup}" started!')
            return True        
        else:
            CLI.print_fail(f'Could not start host group "{hostgroup}!')
            return False    
    else:
        sf = SupportFiles(supportfiles)
        if sf.issues:
            for issue in sf.issues:
                CLI.print_fail(f'Error reading support files: {issue}')      
            return False

        for host in sf.result:
            hostname = hosts.create(hostgroup, host, sf.result[host])
            
            if hostname:
                CLI.print_ok(f'Host container "{hostname}" started!')
            else:        
                CLI.print_fail(f'Could not start host container for host "{host}"!')

    return True

def hosts_status(hosts: HostsStack, hostgroup: str, details: bool = False) -> bool:
    """Prints the status of the host containers for all/requested host groups on screen
    and returns operational state."""
        
    overall_state = True

    json_obj = {}
    for group in hosts.hostgroups:
        
        CLI.print_header(group, margin_bottom=1)

        json_obj[group] = []
        output = []
        for host in hosts.filter_containers(filter={'hostgroup': group}, sortkey='hostgroup'):
           
            host_status = {'name': host['name'], 
                        'status': CLI.ok if host['status'] == 'running' else CLI.error,
                        'status_text': host['status']
                        }
            host_json = {'name': host['name'], 'status': host['status']}
            if details:    
                host_status['details'] = {}
                host_json['details'] = {}
                for key in 'agent_id', 'hostgroup', 'supportconfig', 'supportfiles':
                    value = host[key]
                    host_json['details'][key] = value
                    if isinstance(value, list):
                        value = '\n\t'.join(value.split())
                    host_status['details'][key] = value
                       
            output.append(host_status)       
            json_obj[group].append(host_json)
            
        CLI.print_status(output)
        CLI.print()
    CLI.print_json(json_obj)
   
    return overall_state
        

def hosts_stop(hosts: HostsStack, hostgroup: str) -> bool:
    """Stops host containers of a given hostgroup."""

    #TODO: JSON OUTPUT
    
    if hostgroup:
        if hostgroup not in hosts.hostgroups:
            CLI.print_fail(f'Host group "{hostgroup}" does not exist!.')
            return False
        hostgroups = [hostgroup]
    else:
        hostgroups = hosts.hostgroups

    success = True
    for hostgroup in hostgroups:
        stop_msg = f'Host group "{hostgroup}" completely stopped.' if hostgroup else 'All host groups completely stopped.'
        try:
            stopped = hosts.stop_hostgroup(hostgroup)
        except HostsException as err:
            CLI.print_fail(err)
            success = False
        else:
            if stopped:
                CLI.print_info(f'''Stopped containers: {', '.join(stopped)}''')
            CLI.print_ok(stop_msg)
    
    return success


def hosts_remove(hosts: HostsStack, hostgroup: str) -> bool:
    """Removes host containers of a given hostgroup."""

    #TODO: JSON OUTPUT

    if hostgroup:
        if hostgroup not in hosts.hostgroups:
            CLI.print_fail(f'Host group "{hostgroup}" does not exist!.')
            return False
        hostgroups = [hostgroup]
    else:
        hostgroups = hosts.hostgroups

    success = True
    for hostgroup in hostgroups:
        stop_msg = f'Host group "{hostgroup}" completely removed.' if hostgroup else 'All host groups completely removed.'
        try:
            removed = hosts.remove_hostgroup(hostgroup)
        except HostsException as err:
            CLI.print_fail(err)
            success = False
        else:
            if removed:
                CLI.print_info(f'''Removed containers: {', '.join(removed)}''')
            CLI.print_ok(stop_msg)
    
    return success


def hosts_logs(hosts: HostsStack, containername: str, last_lines: int) -> None:
    """Prints logs of given container."""
    
    if last_lines:
        CLI.print_logline(hosts.logs(containername)[-last_lines:])
        json_obj = hosts.logs(containername)[-last_lines:]
    else:
        CLI.print_logline(hosts.logs(containername))
        json_obj = hosts.logs(containername)
    CLI.print_json(json_obj)
    

def checks_list(wanda: WandaStack, details: bool = False) -> None:
    """Prints the checks on screen returned by Wanda."""

    requested_attributes = ['id', 
                            'description', 
                            'group', 
                            'metadata.provider', 
                            'metadata.cluster_type', 
                            'facts[].gatherer',
                            'expectations[].type',
                           ] if details else ['id', 'description', 'group']
    check_counter, supported, unsupported, unknown  = 0, 0, 0, 0
       
    check_groups = {}

    for check in wanda.checks(requested_attributes):
        if check.group not in check_groups:
                check_groups[check.group] = []
        check_groups[check.group].append(check)

    json_obj = {'checks': {}}
    for check_group in check_groups:
    
        CLI.print_header(check_group, margin_bottom=1)
        output = []
        json_obj['checks'][check_group] = []
        for check in check_groups[check_group]:
            check_counter += 1
            support = getattr(check, 'tcsc_support')
            if support == 'yes':
                supported += 1
                status = CLI.ok
                status_text = 'supported'
            elif support == 'no': 
                unsupported += 1
                status = CLI.error
                status_text = 'not supported'
            else:
                unknown += 1
                status = CLI.warn
                status_text = 'unknown'
                
            check_output = {'name': f'{check.id} - {check.description}', 
                            'status': status,
                            'status_text': status_text 
                           }
            check_json = {'name': f'{check.id} - {check.description}', 'status': status}
            if details:
                check_output['details'] = {}
                for attribute in ['id', 'description', 'group', 'check_type', 'provider', 'cluster_type', 'gatherer']:
                    value = getattr(check, attribute)
                    if isinstance(value, list):
                        value = ' '.join(set(value))
                    check_output['details'][attribute] = value
                    check_json[attribute] = value
            output.append(check_output) 
            json_obj['checks'][check_group].append(check_json)
                   
        CLI.print_status(output)
        CLI.print()
                
    CLI.print()
    json_obj['stats'] = {'available:': check_counter, 
                         'supported': supported, 
                         'unsupported': unsupported,
                         'unknown': unknown
                        }
    CLI.print_json(json_obj) 
    CLI.print_info(f'{check_counter} checks available ({supported=} {unsupported=} {unknown=}).')


def checks_run(wanda: WandaStack, 
               hosts: HostsStack,
               hostgroup: str, 
               provider: str, 
               check_groups: List[str],
               requested_checks: List[str]) -> bool:
    """Executed the requested checks."""
    
    targets = []
    for host in hosts.filter_containers({'hostgroup': hostgroup}):
        if host['status'] != 'running':
            CLI.print_warn(f'''Host "{host['name']}" has status "{host['status']}".''')
            continue
        targets.append(host)
    
    host_count = len(targets)
    if not targets:
        CLI.print_fail(f'No hosts for host group "{hostgroup}" found.')
        return False
    CLI.print_info(f'''{host_count} hosts for "{hostgroup}": {', '.join(h['name'] for h in targets)}''')

    checks2run = collections.defaultdict(list)
    available, selected = set(), set()
    for check in wanda.checks(['id', 'description', 'group', 'expectations[].type']):
        if check.tcsc_support != 'yes':
            continue
        available.add(check.id)
        if host_count == 1 and check.id == 'multi':
            continue
        if check_groups and check.group not in check_groups:
            continue
        if requested_checks and check.id not in requested_checks:
            continue 
        selected.add(check.id)
        checks2run[check.group].append((check.id, check.description, check.check_type)) 
    skipped = available - selected
    CLI.print_info(f'''{len(skipped)} of {len(available)} checks skipped: {', '.join(skipped)}''')
    CLI.print_info(f'''{len(selected)} of {len(available)} checks selected: {', '.join(selected)}''')    
    if not available:
        CLI.print_fail('No checks to run.')
        return False
    
    for check_group in checks2run:
        print()
        CLI.print_header(check_group)
        for check in checks2run[check_group]:
            id, description, check_type = check
            if check_type == 'single':
                for host in targets:
                    result = wanda.execute_check(provider, [host['agent_id']], [id])
            elif check_type == 'multi':
                result = wanda.execute_check(provider, [h['agent_id'] for h in targets], [id])
            else:
                CLI.print_fail(f'Skipping {id}. Unknown check type "{check_type}".')
                continue


            status, data = result
            if status == 'passing':
                status_code = 0
            elif status == 'warning':
                status_code = 1
            else:
                status_code = 2
            CLI.print_status2(f'[{status:^8}]', f'   {id} - {description}', status_code)
            CLI.print_info(f'\t\t{data}')
            
            #TODO: WE NEED: AGENT - HOSTNAME, FALSE VALUES FROM RESULT, REMEDIATION OF CHECK
            
    return True #TODO: Add fails


def wanda_must_run(wanda: WandaStack, autostart: bool) -> None:
    """If requested, starts the Wanda stack and terminates with an error message,
    if Wanda is not operational."""
    
    if not wanda.status:
        if autostart:
            if wanda_start(wanda):
                return
        CLI.print_fail('Wanda is not operational!') 
        sys.exit(4)
                
                
def main() -> None:
        
    global json_output
        
    arguments = argument_parse()  

    try:
        config = Config('~/.config/tcsc/config')
        wanda = WandaStack(config)

        CLI.no_color = not config.colored_output
        CLI.json = arguments.json_output

        if arguments.selectors == 'wanda':
            
            # tcsc wanda start
            if arguments.wanda_commands == 'start':
                sys.exit(0) if wanda_start(wanda) else sys.exit(4)

            # tcsc wanda stop                
            elif arguments.wanda_commands == 'stop':
                sys.exit(0) if wanda_stop(wanda) else sys.exit(4)
            
            # tcsc wanda status
            elif arguments.wanda_commands == 'status':
                sys.exit(0) if wanda_status(wanda) else sys.exit(4)

        elif arguments.selectors == 'hosts': 
            
            hosts = HostsStack(config)
            
            # tcsc hosts start GROUPNAME [SUPPORTFILE...]
            if arguments.host_commands == 'start':
                wanda_must_run(wanda, config.wanda_autostart)
                sys.exit(0) if hosts_start(hosts, arguments.hostgroup, arguments.supportfiles) else sys.exit(5)
                
            # tcsc hosts status [GROUPNAME]
            elif arguments.host_commands == 'status':
                sys.exit(0) if hosts_status(hosts, arguments.hostgroup, arguments.host_details) else sys.exit(5)
                
            # tcsc hosts stop [GROUPNAME]
            elif arguments.host_commands == 'stop':
                    sys.exit(0) if hosts_stop(hosts, arguments.hostgroup) else sys.exit(5)
            
            # tcsc hosts remove [GROUPNAME]
            elif arguments.host_commands == 'remove':
                    sys.exit(0) if hosts_remove(hosts, arguments.hostgroup) else sys.exit(5)

            # tcsc hosts logs [-l LINES] CONTAINERNAME 
            elif arguments.host_commands == 'logs':
                hosts_logs(hosts, arguments.containername, arguments.last_lines)
                sys.exit(0) 
        
        elif arguments.selectors == 'checks': 
            wanda_must_run(wanda, config.wanda_autostart)
            hosts = HostsStack(config)
                            
            # tcsc wanda checks [-d|--details]
            if arguments.checks_commands == 'list':
                checks_list(wanda, arguments.check_details)
                sys.exit(0)  
                
            # tcsc checks run [-p|--provider PROVIDER] ([-g|--group GROUP]... | [-c|--checks CHECK]...) GROUPNAME
            if arguments.checks_commands == 'run':
                sys.exit(0) if checks_run(wanda, hosts, 
                                          arguments.hostgroup, 
                                          arguments.provider, 
                                          arguments.check_groups,
                                          arguments.requested_checks
                                         ) else sys.exit(6)
    
    except ConfigException as err:
        CLI.print_fail(err, file=sys.stderr)
        sys.exit(1)
    except docker.errors.DockerException as err:
        CLI.print_fail(f'Docker error: {err}', file=sys.stderr)
        sys.exit(2)
    except WandaException as err:
        CLI.print_fail(f'Wanda error: {err}', file=sys.stderr)
        sys.exit(3)
    except HostsException as err:
        CLI.print_fail(f'Hosts error: {err}', file=sys.stderr)
        sys.exit(5)
    except CheckException as err:
        CLI.print_fail(f'Check error: {err}', file=sys.stderr)
        sys.exit(6)    
    
    # Bye.
    CLI.print_fail('An unknown error ocurred!')
    sys.exit(9)

    
if __name__ == '__main__':
    main()