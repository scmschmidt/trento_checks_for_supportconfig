#!/usr/bin/env python3.10
# -*- coding: utf-8 -*-

"""
... TBD ...

Exit Codes:
-----------
    0   Everything went fine.
    1   Exception occurred accessing or parsing the configuration file.
    2   Exception occurred in communicating with Docker.
    3   Exception occurred in communicating with Wanda.
    4   A problem with Wanda ocurred.


ToDo:
-----
    - wanda_status() needs Wanda health check.
    - Rework help output.
    - Implement JSON output
    - Implement signal handling (catching interrupts)
    
    
Future:
-------
    - Implement container creation, update and destruction as well.

    
Changelog:
----------
01.03.2024      v0.0        - and so it begins...
"""

import argparse
import os
import docker
import re
import subprocess
import sys
import termcolor
import textwrap
import time
import json
import uuid
from collections import Counter
from rabbiteer import Rabbiteer
from typing import List, Dict, Tuple


__version__ = '0.0'
__author__ = 'SÃ¶ren Schmidt'
__email__ = 'soren.schmidt@suse.com'
__maintainer__ = __author__
__license__ = "GPLv3"
__status__ = 'Prototype'


# -----------------
# CLASS DEFINITIONS
# -----------------

class CLI():
    """Provides methods to print colored messages on the terminal."""
    
    @classmethod
    def print_info(cls, text: str) -> None:
        print(termcolor.colored(text, 'blue'))
        
    @classmethod
    def print_fail(cls, text: str) -> None:
        print(termcolor.colored(text, 'red'))

    @classmethod
    def print_warn(cls, text: str) -> None:
        print(termcolor.colored(text, 'yellow'))

    @classmethod
    def print_ok(cls, text: str) -> None:
        print(termcolor.colored(text, 'green'))

    @classmethod
    def print_okfail(cls, text: str, fail: bool = True) -> None:
        cls.print_fail(text) if fail else cls.print_ok(text)


class Config():
    """Represents tcsc configuration.
    
        - self.id (str):  UUID used to mark the created containers. 
        - self.wanda_containers (List[str]):  List of all Wanda container names.  
        - self.wanda_tag (str):  Tag used to identify Wanda containers for tcsc.
        - self.docker_timeout (int):  Timeout for docker (and Wanda) operations in seconds.
        - self.wanda_url (str):  URL to connect to the Wanda container.
        
    #TODO: DESCRIBE (DEFAULT) CONFIG CONTENT.
    """

    def __init__(self, configfile: str, create: bool = True) -> None:
        """Loads the configuration from `configfile`. If `create` is
        true and `configfile` does not exists, a default configuration
        will be created.

        Args:
            configfile (str):           Filename of JSON configuration.
            create (bool, optional):    Flag if a default configuration shall be created,
                                        if the config file is missing. Defaults to True.
        """

        configfile = os.path.realpath(os.path.expandvars(os.path.expanduser(configfile)))
        try:
            if not os.path.exists(configfile) and create:
                dir, _ = os.path.split(configfile)
                if dir:
                    os.makedirs(dir, mode=0o700, exist_ok=True)
                with open(configfile, 'w') as f:
                    f.write(json.dumps({
                                       'id': str(uuid.uuid1()),
                                       'wanda_containers': ['tcsc-rabbitmq', 'tcsc-postgres', 'tcsc-wanda'],
                                       'wanda_tag': 'com.suse.tcsc.stack',
                                       'docker_timeout': 10,
                                       'wanda_url': 'http://localhost:4000'
                                       }, indent=4
                                       )
                            )
            with open(configfile) as f:
                config = json.load(f)
                self.id = config['id']
                self.wanda_containers = config['wanda_containers']
                self.wanda_tag = config['wanda_tag']
                self.docker_timeout = abs(int(config['docker_timeout']))
                self.wanda_url = config['wanda_url']
        except Exception as err:
            raise ConfigException(f'Error accessing configuration: {err}')


class ConfigException(Exception):
    pass


class Wanda():
    """Represents a Wanda container stack.
    
        - self._containers (Dict[str, Container]):  Dict with the Wand container instances referenced by name.
        - self._docker (docker.DockerClient):  Instance of DockerClient.
        - self._rabbiteer (Rabbiteer):  Rabbiteer instance to talk to Wanda.
    """

    def __init__(self, config: Config) -> None:
        self._docker: docker.DockerClient = docker.from_env()
        self.timeout = config.docker_timeout
        self._containers = {container.name: container for container in 
                            self._docker.containers.list(all=True, filters={'label': config.wanda_tag})}
        if set(self._containers.keys()) != set(config.wanda_containers):
            raise WandaException('Not all required Wanda containers are present.')
        self._rabbiteer = Rabbiteer(config.wanda_url)

    @property
    def container_status(self) -> Dict[str, str]:
        """Returns a dictionary with all Wanda containers and there current status."""
        
        self._update()
        return {container.name: container.status for container in self._containers.values()}
        
    @property
    def status(self) -> bool:
        """Returns a boolean with the WAnda status.
        """    
        for status in self.container_status.values():
            if status != 'running':
                return False

        try:
            health = self._rabbiteer.health()['database']
            ready = self._rabbiteer.readiness()['ready']
        except:
            return False
        else:
            if ready and health == 'pass':
                return True 

        return False
        
        
    def start(self) -> List[str]:
        """Initiate start of Wanda containers. Only containers, which are in the states
        'exited' or 'created' are going to be started. The method will *not* wait for 
        the containers to be up.
        Returns the names of the started containers."""
        
        started = []
        self._update()
        for container in [c for c in self._containers.values() if c.status in ['exited', 'created']]:
            started.append(container.name)
            container.start()
            
        start_time = time.time()    
        while not self.status:
            if  (time.time() - start_time) > self.timeout: 
                raise WandaException(f'''Timeout of {self.timeout}s reached. Wanda did not became operational after start of containers: {', '.join(started)}''')
            time.sleep(1) 
        
        return started

    def stop(self) -> List[str]:
        """Stops all Wanda containers. Only containers, which are in the state 'running'
        are going to be stopped.
        Returns the names of the stopped containers."""
        
        stopped = []
        self._update()
        for container in [c for c in self._containers.values() if c.status in ['running']]:
            stopped.append(container.name)
            container.stop(timeout=self.timeout)
            
        start_time = time.time()
        while True:
            self._update()
            not_exited = [name for name, status in self.container_status.items() if status != 'exited']
            if not not_exited:
                break
            if  (time.time() - start_time) > self.timeout: 
                raise WandaException(f'''Timeout of {self.timeout}s reached. Container not yet exited: {', '.join(not_exited)}''')
            time.sleep(1)   
        
        return stopped

    def _update(self) -> None:
        """Updates the container objects."""
        for container in self._containers.values():
            container.reload()

class WandaException(Exception):
    pass


# ----------------
# HELPER FUNCTIONS
# ----------------

def argument_parse() -> dict:
    """Evaluates the command line arguments."""

    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]),
                                     #usage='\n'.join(usage),
                                     description='Manages containers to use Wanda checks on support files.',
                                     epilog='')

    parser.add_argument('-j', '--json',
                        dest='json_output',
                        action='store_true',
                        required=False,
                        help='output is done in JSON')  
     
    subparsers = parser.add_subparsers(dest='selectors')
    subparsers.required = True
    
    # Selector: wanda
    parser_wanda = subparsers.add_parser('wanda', help='Manages Wanda container stack')
    
    parser_wanda.add_argument(dest='command',
                              action='store',
                              type=str,
                              choices=['start', 'status', 'stop', 'checks'],
                              help='starts, stops, prints the status of the Wanda stack or lists all available checks')
    
    # Selector: hosts
    parser_hosts = subparsers.add_parser('hosts', help='Manages host containers')
    
    # Selector: checks
    parser_checks = subparsers.add_parser('checks',  help='Executes checks')
     
    args_parsed = parser.parse_args()
    
    return args_parsed


# --------------
# TCSC FUNCTIONS
# --------------

def wanda_start(wanda: Wanda) -> bool:
    """Starts the Wanda stack and returns the success."""

    try:
        started = wanda.start()   
    except WandaException as err:
        CLI.print_fail(err)
        return False
    else:
        if started:
            CLI.print_info(f'''Started containers: {', '.join(started)}''')
        CLI.print_ok('Wanda completely started.')
    return True
        
def wanda_stop(wanda: Wanda) -> bool:
    """Stops the Wanda stack and returns the success."""

    try:
        stopped = wanda.stop()
    except WandaException as err:
        CLI.print_fail(err)
        return False
    else:
        if stopped:
            CLI.print_info(f'''Stopped containers: {', '.join(stopped)}''')
        CLI.print_ok('Wanda completely stopped.')
    return True




def wanda_status(wanda: Wanda) -> bool:
    """Prints the status of Wanda stack on screen
    and returns operational state."""

    for name, status in wanda.container_status.items():
        text = f'{name:<20} [{status}]'
        CLI.print_okfail(text, fail=status != 'running')

    if wanda.status:
        CLI.print_ok('\nWanda is operational.') 
        return True
    else:
        CLI.print_fail('\nWanda is not operational!')
        return False


def main() -> None:
    
    arguments = argument_parse()  
    
    try:
        config = Config('~/.config/tcsc/config')
        wanda = Wanda(config)

        # print(arguments)
        if arguments.selectors == 'wanda':
            
            if arguments.command == 'start':
                sys.exit(0) if wanda_start(wanda) else sys.exit(4)
                
            elif arguments.command == 'stop':
                sys.exit(0) if wanda_stop(wanda) else sys.exit(4)
            
            elif arguments.command == 'status':
                sys.exit(0) if wanda_status(wanda) else sys.exit(4)
                
            elif arguments.command == 'checks':
                pass            
        
        elif arguments.selectors == 'hosts': 
            pass 
        
        elif arguments.selectors == 'checks': 
            pass 
    
    except ConfigException as err:
        print(err, file=sys.stderr)
        sys.exit(1)
    except docker.errors.DockerException as err:
        print(f'Docker error: {err}', file=sys.stderr)
        sys.exit(2)
    except WandaException as err:
        print(f'Wanda error: {err}', file=sys.stderr)
        sys.exit(3)
    
    # Bye.
    sys.exit(0)


    
if __name__ == '__main__':
    main()